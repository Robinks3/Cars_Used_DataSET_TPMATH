"""27/05/2024BELLONCLE Robin - BOTHUA Pierre                                        Projet Base de Données                                        Mathématiques statistique                                        """'''import pandas as pdimport seaborn as snsimport matplotlib.pyplot as pltimport statsmodels.api as sm# Charger le fichier CSVfile_path = 'UserCarData.csv'Data = pd.read_csv(file_path, sep=',')Data.columns = [col.strip() for col in Data.columns]  # Supprimer les espaces autour des noms de colonnes# Afficher les premières lignes pour vérifier le chargementprint(Data.head())# Sélectionner des colonnes pour l'analysecolumns = ["year", "selling_price", "km_driven", "mileage", "engine", "max_power", "seats"]year_data, selling_price_data, km_driven_data, mileage_data, engine_data, max_power_data, seats_data = [Data[col] for col in columns]# Relation entre le prix de vente et les kilomètres parcourusplt.figure(figsize=(10, 6))sns.scatterplot(x=km_driven_data, y=selling_price_data)plt.xlabel('Kilomètres parcourus')plt.ylabel('Prix de vente')plt.title('Relation entre le prix de vente et les kilomètres parcourus')plt.show()# Matrice de corrélationcorrelation_matrix = Data[['selling_price', 'km_driven', 'year', 'mileage', 'max_power']].corr()print(correlation_matrix)sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')plt.title('Matrice de Corrélation')plt.show()# Regression linéaire multiple# Ajout d’une constante pour l’interceptX = sm.add_constant(Data[['year', 'km_driven', 'max_power']])# Ajustement du modèlemodel = sm.OLS(Data['selling_price'], X).fit()# Affichage du résumé du modèleprint(model.summary())# Sélection Pas-à-Pas avec colonnes limitéesdef forward_selection_limited(data, response):    predictors = ['year', 'km_driven', 'max_power']    remaining = set(predictors)    selected = []    current_score, best_new_score = float('inf'), float('inf')    while remaining and current_score == best_new_score:        scores_with_candidates = []        for candidate in remaining:            formula = "{} ~ {}".format(response, ' + '.join(selected + [candidate]))            score = sm.OLS.from_formula(formula, data).fit().aic            scores_with_candidates.append((score, candidate))        scores_with_candidates.sort()        best_new_score, best_candidate = scores_with_candidates.pop(0)        if current_score > best_new_score:            remaining.remove(best_candidate)            selected.append(best_candidate)            current_score = best_new_score    formula = "{} ~ {}".format(response, ' + '.join(selected))    model = sm.OLS.from_formula(formula, data).fit()    return model# Application de la sélection pas-à-pas aux donnéeslimited_model = forward_selection_limited(Data, 'selling_price')print(limited_model.summary())# Prediction function using the modeldef predict_selling_price(model, year, km_driven, max_power):    # Extract coefficients from the model    intercept = model.params['Intercept']    beta_year = model.params['year']    beta_km_driven = model.params['km_driven']    beta_max_power = model.params['max_power']    # Calculate the predicted selling price    predicted_price = (        intercept +        (beta_year * year) +        (beta_km_driven * km_driven) +        (beta_max_power * max_power)    )    return predicted_price# Calcul des valeurs préditesData['predicted_selling_price'] = model.predict(X)# Traçage des valeurs réelles vs valeurs préditesplt.figure(figsize=(10, 6))sns.scatterplot(x=Data['selling_price'], y=Data['predicted_selling_price'])plt.plot([Data['selling_price'].min(), Data['selling_price'].max()],         [Data['selling_price'].min(), Data['selling_price'].max()],         color='red', lw=2)plt.xlabel('Prix de vente réel')plt.ylabel('Prix de vente prédit')plt.title('Prix de vente réel vs Prix de vente prédit')plt.show()# Given values for a car: year=2018, km_driven=60000, max_power=165year = 2018km_driven = 60000max_power = 165# Predict the selling pricepredicted_price = predict_selling_price(limited_model, year, km_driven, max_power)print(f"Predicted selling price for a car from {year} with {max_power} hp and {km_driven} km driven: {predicted_price:.2f}")# Boxplot de la puissance maximale pour les 6 noms les plus fréquentstop_4_names = Data['name'].value_counts().nlargest(6).indexfiltered_data = Data[Data['name'].isin(top_4_names)]plt.figure(figsize=(10, 6))sns.boxplot(data=filtered_data, x='max_power', y='name', notch=True)plt.title("Répartition de la puissance maximale pour les 4 noms les plus fréquents")plt.xlabel("Puissance maximale (max_power)")plt.ylabel("Nom de la marque")plt.show()plt.figure(figsize=(10, 6))sns.boxplot(data=filtered_data, x='selling_price', y='name', notch=True)plt.title("Répartition du prix de ventes pour les 4 noms les plus fréquents")plt.xlabel("Prix de ventes (selling_price)")plt.ylabel("Nom de la marque")plt.show()    ###############################################    #################### ANOVA ####################    ###### Puissance max, kilométrage, année ######    from statsmodels.formula.api import ols###### Prix en fonction de l'année ######## Convert 'year' to categorical variableData['year'] = Data['year'].astype('category')# Convertir 'year' en variable catégorielleData['year'] = Data['year'].astype('category')# Définir le modèle ANOVA avec 'max_power' comme variable dépendante et 'year' comme facteurmodel = ols('max_power ~ C(year)', data=Data).fit()anova_table = sm.stats.anova_lm(model, typ=2)# Afficher les résultats de l'ANOVAprint(anova_table)# Optionnel: sauvegarder les résultats dans un fichier CSVanova_table.to_csv('anova_results.csv')# Visualiser la distribution de max_power par annéeplt.figure(figsize=(12, 8))sns.boxplot(x='year', y='max_power', data=Data)plt.xticks(rotation=90)plt.title('Distribution de la puissance maximale par année')plt.show()###### Prix en fonction de l'année et de la puissance du moteur ######## Définir le modèle ANOVA avec 'selling_price' comme variable dépendante, et 'year' et 'max_power' comme facteursmodel_price = ols('selling_price ~ C(year) + max_power', data=Data).fit()anova_table_price = sm.stats.anova_lm(model_price, typ=2)# Afficher les résultats de l'ANOVAprint(anova_table_price)# Optionnel: sauvegarder les résultats dans un fichier CSVanova_table_price.to_csv('anova_results_selling_price.csv')# Visualiser la distribution de selling_price par annéeplt.figure(figsize=(12, 8))sns.boxplot(x='year', y='selling_price', data=Data)plt.xticks(rotation=90)plt.title('Distribution du prix de vente par année')plt.show()# Visualiser la relation entre max_power et selling_priceplt.figure(figsize=(12, 8))sns.scatterplot(x='max_power', y='selling_price', data=Data, hue='year', palette='viridis', alpha=0.7)plt.title('Relation entre la puissance maximale et le prix de vente')plt.xlabel('Puissance maximale (max_power)')plt.ylabel('Prix de vente (selling_price)')plt.show()# Calcul des valeurs préditesData['predicted_selling_price'] = model.predict(X)'''import pandas as pdimport seaborn as snsimport matplotlib.pyplot as pltimport statsmodels.api as smfrom statsmodels.formula.api import olsimport tkinter as tkfrom tkinter import ttk# Charger le fichier CSVfile_path = 'UserCarData.csv'Data = pd.read_csv(file_path, sep=',')Data.columns = [col.strip() for col in Data.columns]  # Supprimer les espaces autour des noms de colonnes# Afficher les premières lignes pour vérifier le chargementprint(Data.head())# Sélectionner des colonnes pour l'analysecolumns = ["year", "selling_price", "km_driven", "mileage", "engine", "max_power", "seats"]year_data, selling_price_data, km_driven_data, mileage_data, engine_data, max_power_data, seats_data = [Data[col] for col in columns]# Relation entre le prix de vente et les kilomètres parcourusplt.figure(figsize=(10, 6))sns.scatterplot(x=km_driven_data, y=selling_price_data)plt.xlabel('Kilomètres parcourus')plt.ylabel('Prix de vente')plt.title('Relation entre le prix de vente et les kilomètres parcourus')plt.show()# Matrice de corrélationcorrelation_matrix = Data[['selling_price', 'km_driven', 'year', 'mileage', 'max_power']].corr()print(correlation_matrix)sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')plt.title('Matrice de Corrélation')plt.show()# Regression linéaire multiple# Ajout d’une constante pour l’interceptX = sm.add_constant(Data[['year', 'km_driven', 'max_power']])# Ajustement du modèlemodel = sm.OLS(Data['selling_price'], X).fit()# Affichage du résumé du modèleprint(model.summary())# Sélection Pas-à-Pas avec colonnes limitéesdef forward_selection_limited(data, response):    predictors = ['year', 'km_driven', 'max_power']    remaining = set(predictors)    selected = []    current_score, best_new_score = float('inf'), float('inf')    while remaining and current_score == best_new_score:        scores_with_candidates = []        for candidate in remaining:            formula = "{} ~ {}".format(response, ' + '.join(selected + [candidate]))            score = sm.OLS.from_formula(formula, data).fit().aic            scores_with_candidates.append((score, candidate))        scores_with_candidates.sort()        best_new_score, best_candidate = scores_with_candidates.pop(0)        if current_score > best_new_score:            remaining.remove(best_candidate)            selected.append(best_candidate)            current_score = best_new_score    formula = "{} ~ {}".format(response, ' + '.join(selected))    model = sm.OLS.from_formula(formula, data).fit()    return model# Application de la sélection pas-à-pas aux donnéeslimited_model = forward_selection_limited(Data, 'selling_price')print(limited_model.summary())# Prediction function using the modeldef predict_selling_price(model, year, km_driven, max_power):    intercept = model.params['Intercept']    beta_year = model.params['year']    beta_km_driven = model.params['km_driven']    beta_max_power = model.params['max_power']    predicted_price = (        intercept +        (beta_year * year) +        (beta_km_driven * km_driven) +        (beta_max_power * max_power)    )    return predicted_price# Calcul des valeurs préditesData['predicted_selling_price'] = model.predict(X)# Traçage des valeurs réelles vs valeurs préditesplt.figure(figsize=(10, 6))sns.scatterplot(x=Data['selling_price'], y=Data['predicted_selling_price'])plt.plot([Data['selling_price'].min(), Data['selling_price'].max()],         [Data['selling_price'].min(), Data['selling_price'].max()],         color='red', lw=2)plt.xlabel('Prix de vente réel')plt.ylabel('Prix de vente prédit')plt.title('Prix de vente réel vs Prix de vente prédit')plt.show()### IHM De prediction du prix réaliser à l'aide de ChatGPT 4o #### Fonction pour tracer le point du prix prédit sur le graphiquedef plot_predicted_price(predicted_price):    plt.figure(figsize=(10, 6))    sns.scatterplot(x=Data['selling_price'], y=Data['predicted_selling_price'])    plt.plot([Data['selling_price'].min(), Data['selling_price'].max()],             [Data['selling_price'].min(), Data['selling_price'].max()],             color='red', lw=2)    plt.scatter(predicted_price, predicted_price, color='blue', s=100)  # Ajouter le point prédit    plt.xlabel('Prix de vente réel')    plt.ylabel('Prix de vente prédit')    plt.title('Prix de vente réel vs Prix de vente prédit')    plt.show()######################################################## Interface graphique avec Tkinter #########def create_gui():    # Créer la fenêtre principale    root = tk.Tk()    root.title("Estimation du prix de vente des voitures")    # Variables Tkinter pour les curseurs    year_var = tk.IntVar()    km_driven_var = tk.IntVar()    max_power_var = tk.IntVar()    # Fonction de mise à jour appelée lors de la modification des curseurs    def update_price(*args):        year = year_var.get()        km_driven = km_driven_var.get()        max_power = max_power_var.get()        predicted_price = predict_selling_price(limited_model, year, km_driven, max_power)        result_label.config(text=f"Prix estimé: {predicted_price:.2f} €")        plot_predicted_price(predicted_price)    # Ajouter des curseurs pour year, km_driven et max_power    ttk.Label(root, text="Année:").grid(column=0, row=0, padx=10, pady=10)    year_slider = tk.Scale(root, from_=2000, to=2024, orient=tk.HORIZONTAL, variable=year_var)    year_slider.grid(column=1, row=0, padx=10, pady=10)    year_var.trace_add('write', update_price)    ttk.Label(root, text="Kilomètres parcourus:").grid(column=0, row=1, padx=10, pady=10)    km_driven_slider = tk.Scale(root, from_=0, to=300000, orient=tk.HORIZONTAL, variable=km_driven_var)    km_driven_slider.grid(column=1, row=1, padx=10, pady=10)    km_driven_var.trace_add('write', update_price)    ttk.Label(root, text="Puissance maximale:").grid(column=0, row=2, padx=10, pady=10)    max_power_slider = tk.Scale(root, from_=50, to=500, orient=tk.HORIZONTAL, variable=max_power_var)    max_power_slider.grid(column=1, row=2, padx=10, pady=10)    max_power_var.trace_add('write', update_price)    # Ajouter un label pour afficher le résultat    result_label = ttk.Label(root, text="Prix estimé: ")    result_label.grid(column=0, row=3, columnspan=2, padx=10, pady=10)    # Lancer l'application    root.mainloop()# Appeler la fonction pour créer l'IHMcreate_gui()