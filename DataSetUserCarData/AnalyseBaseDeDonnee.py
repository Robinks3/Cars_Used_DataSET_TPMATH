"""27/05/2024BELLONCLE Robin - BOTHUA Pierre                                        Projet Base de Données                                        Mathématiques statistique                                        """'''import pandas as pdimport numpy as npimport seaborn as snsimport statsmodels.api as smimport matplotlib.pyplot as pltimport scipy.stats as statsimport matplotlib.pyplot as pltimport seaborn as snsfrom scipy import statsimport statsmodels.api as smfrom statsmodels.formula.api import olsfrom sklearn.decomposition import PCA# Charger le fichier CSVfile_path = 'UserCarData.csv'Data = pd.read_csv(file_path, sep=',')Data.columns = [col.strip() for col in Data.columns]  # Supprimer les espaces autour des noms de colonnes# Sélectionner des colonnes pour l'analysecolumns = ["year", "selling_price", "km_driven", "mileage", "engine", "max_power", "seats"]year_data, selling_price_data, km_driven_data, mileage_data, engine_data, max_power_data, seats_data = [Data[col] for col in columns]# Afficher les premières lignes pour vérifier le chargementprint(Data.head())# Relation entre le prix de vente et les kilomètres parcourusplt.figure(figsize=(10, 6))sns.scatterplot(x=km_driven_data, y=selling_price_data)plt.xlabel('Kilomètres parcourus')plt.ylabel('Prix de vente')plt.title('Relation entre le prix de vente et les kilomètres parcourus')plt.show()# Matrice de corrélationcorrelation_matrix = Data[['selling_price', 'km_driven', 'year', 'mileage', 'max_power']].corr()print(correlation_matrix)sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')plt.title('Matrice de Corrélation')plt.show()#Regression linéaire multipl# Ajout d’une constante pour l’interceptX = sm.add_constant(Data[['year', 'km_driven', 'max_power']])# Ajustement du modelemodel = sm.OLS(Data['selling_price'], X).fit()# Affichage du r´esum´e du mod`eleprint(model.summary())#Prediction du modèle#new_data = pd.DataFrame({'km_driven', 'max_power'})#new_data = sm.add_constant(new_data)#predictions = model.get_prediction(new_data)#print(predictions.summary_frame(alpha=0.05))#S´election Pas-`a-Pasdef forward_selection(data, response):    remaining = set(data.columns)    remaining.remove(response)    selected = []    current_score, best_new_score = float('inf'), float('inf')    while remaining and current_score == best_new_score:        scores_with_candidates = []        for candidate in remaining:            formula = "{} ~ {}".format(response,' + '.join(selected + [candidate]))            score = sm.OLS.from_formula(formula, data).fit().aic            scores_with_candidates.append((score, candidate))        scores_with_candidates.sort()    best_new_score, best_candidate = scores_with_candidates.pop(0)    if current_score > best_new_score:         remaining.remove(best_candidate)         selected.append(best_candidate)         current_score = best_new_score    formula = "{} ~ {}".format(response, ' + '.join(selected))    model = sm.OLS.from_formula(formula, data).fit()    return modelmodel = forward_selection(Data, 'selling_price')print(model.summary())'''        """27/05/2024BELLONCLE Robin - BOTHUA Pierre                                        Projet Base de Données                                        Mathématiques statistique                                        """import pandas as pdimport seaborn as snsimport matplotlib.pyplot as pltimport statsmodels.api as sm# Charger le fichier CSVfile_path = 'UserCarData.csv'Data = pd.read_csv(file_path, sep=',')Data.columns = [col.strip() for col in Data.columns]  # Supprimer les espaces autour des noms de colonnes# Afficher les premières lignes pour vérifier le chargementprint(Data.head())# Sélectionner des colonnes pour l'analysecolumns = ["year", "selling_price", "km_driven", "mileage", "engine", "max_power", "seats"]year_data, selling_price_data, km_driven_data, mileage_data, engine_data, max_power_data, seats_data = [Data[col] for col in columns]# Relation entre le prix de vente et les kilomètres parcourusplt.figure(figsize=(10, 6))sns.scatterplot(x=km_driven_data, y=selling_price_data)plt.xlabel('Kilomètres parcourus')plt.ylabel('Prix de vente')plt.title('Relation entre le prix de vente et les kilomètres parcourus')plt.show()"""# Matrice de corrélationcorrelation_matrix = Data[['selling_price', 'km_driven', 'year', 'mileage', 'max_power']].corr()print(correlation_matrix)sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm')plt.title('Matrice de Corrélation')plt.show()# Regression linéaire multiple# Ajout d’une constante pour l’interceptX = sm.add_constant(Data[['year', 'km_driven', 'max_power']])# Ajustement du modèlemodel = sm.OLS(Data['selling_price'], X).fit()# Affichage du résumé du modèleprint(model.summary())# Sélection Pas-à-Pas avec colonnes limitéesdef forward_selection_limited(data, response):    predictors = ['year', 'km_driven', 'max_power']    remaining = set(predictors)    selected = []    current_score, best_new_score = float('inf'), float('inf')    while remaining and current_score == best_new_score:        scores_with_candidates = []        for candidate in remaining:            formula = "{} ~ {}".format(response, ' + '.join(selected + [candidate]))            score = sm.OLS.from_formula(formula, data).fit().aic            scores_with_candidates.append((score, candidate))        scores_with_candidates.sort()        best_new_score, best_candidate = scores_with_candidates.pop(0)        if current_score > best_new_score:            remaining.remove(best_candidate)            selected.append(best_candidate)            current_score = best_new_score    formula = "{} ~ {}".format(response, ' + '.join(selected))    model = sm.OLS.from_formula(formula, data).fit()    return model# Application de la sélection pas-à-pas aux donnéeslimited_model = forward_selection_limited(Data, 'selling_price')print(limited_model.summary())# Prediction function using the modeldef predict_selling_price(model, year, km_driven, max_power):    # Extract coefficients from the model    intercept = model.params['Intercept']    beta_year = model.params['year']    beta_km_driven = model.params['km_driven']    beta_max_power = model.params['max_power']    # Calculate the predicted selling price    predicted_price = (        intercept +        (beta_year * year) +        (beta_km_driven * km_driven) +        (beta_max_power * max_power)    )    return predicted_price"""# Given values for a car: year=2018, km_driven=60000, max_power=165year = 2018km_driven = 60000max_power = 165# Predict the selling price#predicted_price = predict_selling_price(limited_model, year, km_driven, max_power)#print(f"Predicted selling price for a car from {year} with {max_power} hp and {km_driven} km driven: {predicted_price:.2f}")    ###############################################    #################### ANOVA ####################    ###### Puissance max, kilométrage, année ######    from statsmodels.formula.api import ols"""###### Prix en fonction de l'année ######## Convert 'year' to categorical variableData['year'] = Data['year'].astype('category')# Convertir 'year' en variable catégorielleData['year'] = Data['year'].astype('category')# Définir le modèle ANOVA avec 'max_power' comme variable dépendante et 'year' comme facteurmodel = ols('max_power ~ C(year)', data=Data).fit()anova_table = sm.stats.anova_lm(model, typ=2)# Afficher les résultats de l'ANOVAprint(anova_table)# Optionnel: sauvegarder les résultats dans un fichier CSVanova_table.to_csv('anova_results.csv')# Visualiser la distribution de max_power par annéeplt.figure(figsize=(12, 8))sns.boxplot(x='year', y='max_power', data=Data)plt.xticks(rotation=90)plt.title('Distribution de la puissance maximale par année')plt.show()"""###### Prix en fonction de l'année et de la puissance du moteur ######## Définir le modèle ANOVA avec 'selling_price' comme variable dépendante, et 'year' et 'max_power' comme facteursmodel_price = ols('selling_price ~ C(year) + max_power', data=Data).fit()anova_table_price = sm.stats.anova_lm(model_price, typ=2)# Afficher les résultats de l'ANOVAprint(anova_table_price)# Optionnel: sauvegarder les résultats dans un fichier CSVanova_table_price.to_csv('anova_results_selling_price.csv')# Visualiser la distribution de selling_price par annéeplt.figure(figsize=(12, 8))sns.boxplot(x='year', y='selling_price', data=Data)plt.xticks(rotation=90)plt.title('Distribution du prix de vente par année')plt.show()# Visualiser la relation entre max_power et selling_priceplt.figure(figsize=(12, 8))sns.scatterplot(x='max_power', y='selling_price', data=Data, hue='year', palette='viridis', alpha=0.7)plt.title('Relation entre la puissance maximale et le prix de vente')plt.xlabel('Puissance maximale (max_power)')plt.ylabel('Prix de vente (selling_price)')plt.show()